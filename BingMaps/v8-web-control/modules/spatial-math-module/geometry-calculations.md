---
title: "Geometry Calculations | Microsoft Docs"
ms.custom: ""
ms.date: "02/28/2018"
ms.reviewer: ""
ms.suite: ""
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: 8bbdc23b-24ac-40a1-8561-619bb0bdd0be
caps.latest.revision: 6
author: "rbrundritt"
ms.author: "richbrun"
manager: "stevelom"
ms.service: "bing-maps"
---
# Geometry Calculations
A set of methods that perform spatial calculations against shapes. These static methods are exposed through the `Microsoft.Maps.SpatialMath.Geometry` namespace.

> [!NOTE]
> Many of these calculations allow an array of IPrimitives shapes to be passed in a single shape. This is to allow complex shapes such as MultiPolygons and GeometryCollections to be used in these calculations.

| Name                                 | Return Type                      | Description                                                 |
|--------------------------------------|----------------------------------|-------------------------------------------------------------|
| area(shape: [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\], [AreaUnits](../v8-web-control/areaunits-enumeration.md)?: [AreaUnits](../v8-web-control/areaunits-enumeration.md))    | number      | Calculates the area of a shape and returns a value in the specified area units. Default units is square meters.   |
| bounds(shapes: [Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ ([Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md))\[\])  | [LocationRect](../v8-web-control/locationrect-class.md)       | Calculates a bounding box that encloses a set of shapes and/or Locations.   |
| buffer(shape: [Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ ([Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md))\[\], distance: number, units?: [DistanceUnits](../v8-web-control/distanceunits-enumeration.md), endCapType?: [BufferEndCap](../v8-web-control/bufferendcap-enumeration.md), options?: [PolygonOptions](../v8-web-control/polygonoptions-object.md))  | [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\] | Calculates a shape with an updated boundary that has been inflated/deflated by a specified distance.<br/><br/> • **distance** - The distance to buffer the shape by. <br/> • **units** - The distance units to buffer the shape by. <br/> • **endCapType** - The type of end cap to use for the joints of the buffer, default value is round.<br/><br/>**Tip**: If buffering a Location or Pushpin, use the SpatialMath.getRegularPolygon function with 36 or more points to generate an approximated circle. This will result in a more geospatially accurately buffered shape.|
| calculateLength(shape: [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\], units ?: [DistanceUnits](../v8-web-control/distanceunits-enumeration.md), highAccuracy ?: boolean)      | number  | Calculates the distance between all Locations in a shape. If the shape is a Polygon, the length of the perimeter of all rings is calculated. <br/><br/> • **units** - Unit of distance measurement. Default: **Meters** <br/> • **highAccuracy** - If set to true, uses the more accurate Vincenty’s algorithm for calculating distances. Otherwise the faster Haversine formula is used.   |
| centroid(shape: [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\]) | [Location](../v8-web-control/location-class.md)        | Calculates the center of a shape.     |
| concaveHull(shapes: [Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ ([Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md))\[\], allowMultiPolygons?: boolean, allowHoles?: boolean, options?: [PolygonOptions](../v8-web-control/polygonoptions-object.md))                                          | [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\] | Calculates an approximate concave hull that best fits the data. A concave hull is a shape that represents that a possible concave geometry that encloses all shapes in the specified data set. If a single unique Location is in the data set, a Pushpin is returned. If only two unique Locations are provided, or if all Locations form a line, a Polyline is returned. If 3 or more unique Locations are in the data set a Polygon, or array of Polygons will be returned. <br/><br/> • **allowMultiPolygons** - A boolean indicating if the resulting concave hull can be a MultiPolygon. Default: **false** <br/> • **allowHoles** - A boolean indicating if the Polygons in the resulting concave hull can have holes in them. Default: **false** |
| contains(shapeA:  [Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ ([Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md))\[\], shapeB:  [Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ ([Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md))\[\] | boolean | Given two shapes, determines if the first one contains the second one (or, the second shape is a subset of the first shape) or not. |
| convexHull(shapes: [Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ ([Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md))\[\], options?: [PolygonOptions](../v8-web-control/polygonoptions-object.md))     | [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\] | Calculates a convex hull. A convex hull is a shape that represents that minimum convex geometry that encloses all shapes in the specified data set.   |
| delaunayTriangles(shapes: [Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ ([Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md))\[\], options?: [PolygonOptions](../v8-web-control/polygonoptions-object.md))                                                                                        | [Polygon](../v8-web-control/polygon-class.md)\[\]       | Creates Delaunay Triangles from the Location objects of the provided shapes.    |
| difference(shapeA: [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\], shapeB: [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\])     | [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\] | Returns an object that represents area of an initial shape subtracted by the overlapping area of a second shape.  |
| distance(shapeA: [Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ ([Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md))\[\], shapeB: [Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ ([Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md))\[\], units?: [DistanceUnits](../v8-web-control/distanceunits-enumeration.md), highAccuracy?: boolean) | number                           | Calculates the approximate shortest distance between any two shapes. <br/><br/> • **units** - Unit of distance measurement. Default: **Meters**<br/> • **highAccuracy** - If set to true, uses the more accurate Vincenty’s algorithm for calculating distances. Otherwise the faster Haversine formula is used.    |
| intersection(shapeA: [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\], shapeB: [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\])   | [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\] | Returns an object that represents the area where two shapes intersect.|
| intersects(shapeA: [Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ ([Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md))\[\], shapeB: [Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ ([Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md))\[\])   | boolean      | Determines if two shapes intersect or not. |
| isValid(shape: [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\])   | boolean   | Tests to see if the shape is valid and meets the requirements of an SQL Geography type and other OGC compliant systems. Polylines & Polygons can't be self-intersecting. For Polygons, coordinates in an exterior rings have a counter-clockwise orientation, while holes have a clockwise orientation.  |
| makeValid(shape: [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\])   | [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\] | Takes a shape and returns a copy of it that meets the requirements of an SQL Geography type and other OGC compliant systems. Polylines & Polygons can't be self-intersecting. For Polygons, coordinates in an exterior rings have a counter-clockwise orientation, while holes have a clockwise orientation.  |
| nearestLocations(shapeA: [Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ ([Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md))\[\], shapeB: [Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ ([Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md))\[\])  | [Location](../v8-web-control/location-class.md)\[\]  | Calculates the nearest Location objects between to shapes that lie on the shapes. If the shapes do not overlap, this calculates a Location on each shape that is closest to the other shape. If the shapes overlap, a Location that is within the intersection area of the shapes will be added twice to an array, once for each shape, and returned.  |
| reduce(shape: [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\], tolerance: number)       | [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\] | Reduces the resolution of a shape using the Douglas-Peucker algorithm. The tolerance parameter is distance in meters used by the reduction algorithms. |
| rotate(shape: [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\], angle: number, origin?: [Location](../v8-web-control/location-class.md)) |     | Rotates a shape around a given Location for the specified angle of rotation. If an origin is not provided, the centroid of the shape is used. <br/><br/> • **angle** - The amount to rotate the shape in degrees. <br/> • **origin** - The Location to rotate the shape around. Defaults to the centroid of the shape.   |
| shortestLineTo(shapeA: [Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ ([Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md))\[\], shapeB: [Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ ([Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md))\[\], options?: IPolylineOptions)   | Polyline  | Calculates the shortest path that between two shapes and returns a Polyline.  |
| snapLocationsToShape(locs: [Location](../v8-web-control/location-class.md) _or_ [Location](../v8-web-control/location-class.md)\[\], shape: [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\], tolerance?: number, toleranceUnits?: [DistanceUnits](../v8-web-control/distanceunits-enumeration.md))   | [Location](../v8-web-control/location-class.md) _or_ [Location](../v8-web-control/location-class.md)\[\]     | Snaps the Locations of one shape that are within the specified tolerance distance away from another shape. <br/><br/> • **tolerance** - A maximum distance (in the specified units) that the snapped Location can be from the input Location. Default: **Infinity** <br/> • **toleranceUnits** - The distance units of the tolerance value. Default: **Meters**   |
| snapShapeToShape(shapeToSnap: [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\], shape: [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\], tolerance?: number, toleranceUnits?: [DistanceUnits](../v8-web-control/distanceunits-enumeration.md))                                                    |                                  | Snaps the Locations of one shape that are within the specified tolerance distance away from another shape. <br/><br/> • **tolerance** - A maximum distance (in the specified units) that the snapped Location can be from the input Location. Default: **Infinity** <br/> • **toleranceUnits** - The distance units of the tolerance value. Default: **Meters**  |
| symDifference(shapeA: [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\], shapeB: [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\])    | [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\] | Returns an object that represents all points that are either in one shape instance or another, but not those points that lie in both instances. "Sym" stands for Symmetric. symDifference is an OGC standard name for this calculation used in most spatial math libraries, including SQL.   |
| union(shapeA: [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\], shapeB: [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\]) | [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\] | Returns an object that represents the union of two shapes. If shapes don't overlap, an array of each individual shapes will be returned. |
| unionAggregate(shapes: [IPrimitive](../v8-web-control/iprimitive-class.md)\[\])   | [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md)\[\] | Performs a union operation on a set of shapes. If a shape doesn't overlap with the rest, the returned result will be an array of shapes containing this shape and the union of the rest.  |
| voronoiDiagram(shapes: [Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md) _or_ ([Location](../v8-web-control/location-class.md) _or_ [IPrimitive](../v8-web-control/iprimitive-class.md))\[\], clipRegion?: [LocationRect](../v8-web-control/locationrect-class.md) _or_ [Polygon](../v8-web-control/polygon-class.md), options?: [PolygonOptions](../v8-web-control/polygonoptions-object.md))   | [Polygon](../v8-web-control/polygon-class.md)\[\]      | Creates a Voronoi diagram from the Location objects of the provided shapes. The diagram is returned as an array of Polygons. If a clip region is specified, the diagram will be clipped accordingly.  |

**Important Note:** Many of these calculations use 2D geometry calculations with different projected planes to approximate there equivalent spatially accurate calculations. This introduces a margin of error. When testing the area calculation and comparing the results to the geography area calculation in SQL, the following differences in calculated values where observed when testing against shapes of different sizes:

| Approximate Boundary Size | V8 Area (meters) | SQL Geoography Area (meters) | Difference |
|---------------------------|------------------|------------------------------|------------|
| Residential Property      | 3721.63          | 3723.94                      | 0.062%     |
| City                      | 68204696         | 68241644                     | 0.054%     |
| US State Boundary         | 186866383894     | 187876559258                 | 0.54%      |
| USA Country               | 8569210057215    | 8693955435213                | 1.45%      |

If you require higher accuracy spatial calculations, create a webservice and use the [Microsoft SQL Server Spatial Types library](https://www.nuget.org/packages/Microsoft.SqlServer.Types). This is a .NET library that can be used on its own and doesn't require installing SQL.

Also note, there may be instances where, when visualizing results of a calculations, they look to have a larger margin of error. For instance, the calculated centroid of a 100KM line may appear to be several meters away from the line itself. The reason for this is that due to the Mercator projection of the map, “straight lines” between two locations should in fact be rendered as curved geodesic lines, however, for simplicity and performance, the map renders a geometric straight line. If you were to pass the line through the `getGeodesicPath` function the line and the centroid would intersect.

There is partial support for shapes which cross the anti-merdian (-180/180 degrees longitude). To help reduce "world wrap" issues, the spatial math module automatically splits result shapes along this line if they cross the anti-merdian.
